<channel version="3.10.0">
  <id>321b5cb3-a422-4341-a177-c9e1c8837702</id>
  <nextMetaDataId>6</nextMetaDataId>
  <name>PDF report generation</name>
  <description></description>
  <revision>5</revision>
  <sourceConnector version="3.10.0">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.js.JavaScriptReceiverProperties" version="3.10.0">
      <pluginProperties/>
      <pollConnectorProperties version="3.10.0">
        <pollingType>INTERVAL</pollingType>
        <pollOnStart>false</pollOnStart>
        <pollingFrequency>30000</pollingFrequency>
        <pollingHour>0</pollingHour>
        <pollingMinute>0</pollingMinute>
        <cronJobs/>
        <pollConnectorPropertiesAdvanced>
          <weekly>true</weekly>
          <inactiveDays>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
          </inactiveDays>
          <dayOfMonth>1</dayOfMonth>
          <allDay>true</allDay>
          <startingHour>8</startingHour>
          <startingMinute>0</startingMinute>
          <endingHour>17</endingHour>
          <endingMinute>0</endingMinute>
        </pollConnectorPropertiesAdvanced>
      </pollConnectorProperties>
      <sourceConnectorProperties version="3.10.0">
        <responseVariable>None</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <script>return &quot;test&quot;;</script>
    </properties>
    <transformer version="3.10.0">
      <elements>
        <com.mirth.connect.plugins.mapper.MapperStep version="3.10.0">
          <name>Message code</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <variable>Message code</variable>
          <mapping>msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString().trim()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="3.10.0">
          <name>Message Trigger Event</name>
          <sequenceNumber>1</sequenceNumber>
          <enabled>true</enabled>
          <variable>Message Trigger Event</variable>
          <mapping>msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString().trim()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="3.10.0">
          <name>First Name</name>
          <sequenceNumber>2</sequenceNumber>
          <enabled>true</enabled>
          <variable>First Name</variable>
          <mapping>msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString().trim()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="3.10.0">
          <name>Last Name</name>
          <sequenceNumber>3</sequenceNumber>
          <enabled>true</enabled>
          <variable>Last Name</variable>
          <mapping>msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString().trim()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="3.10.0">
          <name>Date Of Birth</name>
          <sequenceNumber>4</sequenceNumber>
          <enabled>true</enabled>
          <variable>Date Of Birth</variable>
          <mapping>msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString().trim()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.10.0">
          <name>Conversion</name>
          <sequenceNumber>5</sequenceNumber>
          <enabled>true</enabled>
          <script>var hl7JsonObject = {};
hl7JsonObject.first_name = msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
hl7JsonObject.last_name = msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
hl7JsonObject.date_of_birth = moment(msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString(), &apos;YYYYMMDD&apos;).format(&apos;YYYY-MM-DD&apos;);
channelMap.put(&apos;hl7_json_object&apos;, hl7JsonObject);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64">TVNIfF5+XCZ8U1lTVEVNLUF8c3lzdGVtQXxTWVNURU0tQnxzeXN0ZW1CfDE5OTkxMjI3MTQwOHx8QURUXkEwNHw3NDU3fER8Mi41fApQSUR8fDA0OTM1NzVeXl4yXklEIDF8NDU0NzIxfHxET0VeSk9ITl5eXl58RE9FXkpPSE5eXl5efDE5NDgwMjAzfE18fEJ8MjU0IE1ZU1RSRUVUIEFWRV5eTVlUT1dOXk9IXjQ0MTIzXlVTQXx8KDIxNikxMjMtNDU2N3x8fE18Tk9OfDQwMDAwMzQwM34xMTI5MDg2fApQVjF8fE98MTY4IH4yMTl+Q35QTUFeXl5eXl5eXl58fHx8Mjc3XkFMTEVOIE1ZTEFTVE5BTUVeQk9OTklFXl5eXnx8fHx8fHx8fHwgfHwyNjg4Njg0fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fDE5OTkxMjI3MTQwOHx8fHx8fDAwMjM3Njg1MwpOSzF8fFJPRV5NQVJJRV5eXl58U1BPfHwoMjE2KTEyMy00NTY3fHxFQ3x8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fAo=</inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>HL7V2</inboundDataType>
      <outboundDataType>HL7V2</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
          <handleRepetitions>true</handleRepetitions>
          <handleSubcomponents>true</handleSubcomponents>
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <stripNamespaces>true</stripNamespaces>
          <segmentDelimiter>\r</segmentDelimiter>
          <convertLineBreaks>true</convertLineBreaks>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <segmentDelimiter>\r</segmentDelimiter>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
          <splitType>MSH_Segment</splitType>
          <batchScript></batchScript>
        </batchProperties>
        <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
          <segmentDelimiter>\r</segmentDelimiter>
          <successfulACKCode>AA</successfulACKCode>
          <successfulACKMessage></successfulACKMessage>
          <errorACKCode>AE</errorACKCode>
          <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
          <rejectedACKCode>AR</rejectedACKCode>
          <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
          <msh15ACKAccept>false</msh15ACKAccept>
          <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
        </responseGenerationProperties>
        <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
          <successfulACKCode>AA,CA</successfulACKCode>
          <errorACKCode>AE,CE</errorACKCode>
          <rejectedACKCode>AR,CR</rejectedACKCode>
          <validateMessageControlId>true</validateMessageControlId>
          <originalMessageControlId>Destination_Encoded</originalMessageControlId>
          <originalIdMapVariable></originalIdMapVariable>
        </responseValidationProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
          <handleRepetitions>true</handleRepetitions>
          <handleSubcomponents>true</handleSubcomponents>
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <stripNamespaces>true</stripNamespaces>
          <segmentDelimiter>\r</segmentDelimiter>
          <convertLineBreaks>true</convertLineBreaks>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <segmentDelimiter>\r</segmentDelimiter>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
          <splitType>MSH_Segment</splitType>
          <batchScript></batchScript>
        </batchProperties>
        <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
          <segmentDelimiter>\r</segmentDelimiter>
          <successfulACKCode>AA</successfulACKCode>
          <successfulACKMessage></successfulACKMessage>
          <errorACKCode>AE</errorACKCode>
          <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
          <rejectedACKCode>AR</rejectedACKCode>
          <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
          <msh15ACKAccept>false</msh15ACKAccept>
          <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
        </responseGenerationProperties>
        <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
          <successfulACKCode>AA,CA</successfulACKCode>
          <errorACKCode>AE,CE</errorACKCode>
          <rejectedACKCode>AR,CR</rejectedACKCode>
          <validateMessageControlId>true</validateMessageControlId>
          <originalMessageControlId>Destination_Encoded</originalMessageControlId>
          <originalIdMapVariable></originalIdMapVariable>
        </responseValidationProperties>
      </outboundProperties>
    </transformer>
    <filter version="3.10.0">
      <elements/>
    </filter>
    <transportName>JavaScript Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="3.10.0">
      <metaDataId>1</metaDataId>
      <name>Fields Validation</name>
      <properties class="com.mirth.connect.connectors.js.JavaScriptDispatcherProperties" version="3.10.0">
        <pluginProperties/>
        <destinationConnectorProperties version="3.10.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <script>// Validation

const fullName = $(&apos;Last Name&apos;) + &quot; &quot; + $(&apos;First Name&apos;);
const dateOfBirth = $(&apos;Date Of Birth&apos;);

const fullNamePattern = /^([a-zA-Z]{2,}\s[a-zA-Z]{1,}&apos;?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)/g;
const dateOfBirthPattern = /([12]\d{3}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01]))/g;

const isFullNameValid = fullName.match(fullNamePattern);
const isDateOfBirthValid = dateOfBirth.match(dateOfBirthPattern);

function isNotNull (value) {
	return value !== null &amp;&amp; value.length === 1;
}

//logger.info(&quot;Is Full name valid? &quot; + isNotNull(isFullNameValid));
//logger.info(&quot;Is date of birth valid? &quot; + isNotNull(isDateOfBirthValid));
logger.info(&quot;Our JSON object in plain text: &quot; + JSON.stringify($(&apos;hl7_json_object&apos;)));</script>
      </properties>
      <transformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.10.0">
        <elements/>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.10.0">
      <metaDataId>3</metaDataId>
      <name>MySQL insert query</name>
      <properties class="com.mirth.connect.connectors.jdbc.DatabaseDispatcherProperties" version="3.10.0">
        <pluginProperties/>
        <destinationConnectorProperties version="3.10.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <driver>com.mysql.cj.jdbc.Driver</driver>
        <url>jdbc:mysql://localhost:3306/mydatabase</url>
        <username>root</username>
        <password>root</password>
        <query>INSERT INTO patients (firstname, lastname, dateofbirth)
VALUES (${maps.get(&apos;First Name&apos;)}, ${maps.get(&apos;Last Name&apos;)}, ${maps.get(&apos;Date Of Birth&apos;)})

</query>
        <useScript>false</useScript>
      </properties>
      <transformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.10.0">
        <elements/>
      </filter>
      <transportName>Database Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.10.0">
      <metaDataId>5</metaDataId>
      <name>PDF report</name>
      <properties class="com.mirth.connect.connectors.doc.DocumentDispatcherProperties" version="3.10.0">
        <pluginProperties/>
        <destinationConnectorProperties version="3.10.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <host>/Users/mbrazi/Documents/reports</host>
        <outputPattern>patient_data.pdf</outputPattern>
        <documentType>pdf</documentType>
        <encrypt>false</encrypt>
        <output>FILE</output>
        <password></password>
        <pageWidth>8.5</pageWidth>
        <pageHeight>11</pageHeight>
        <pageUnit>INCHES</pageUnit>
        <template>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;style&gt;
        body {
            font-family: &quot;Open Sans&quot;, sans-serif;
            padding: 25px;
        }

        table {
            border: .5px solid #ccc;
            width: 100%;
            table-layout: fixed;
        }

        h3 {
            font-size: 1.5em;
            margin: .5em 0 .75em;
            text-align: center;
        }

        table tr {
            background-color: #f8f8f8;
            border: .5px solid #ddd;
            padding: .35em;
        }

        table th,
        table td {
            padding: .625em;
        }

        table th {
            font-size: .85em;
            text-transform: uppercase;
            background-color: #333;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h3&gt;PDF Report - Patient data&lt;/h3&gt;
    &lt;br /&gt;
    &lt;p&gt;This is a report that summarize patient information (name, date of birth). You can always change your HTML
        CSS template here. Let&apos;s see how much creative are you in designing PDF reports using pure HTML CSS?&lt;/p&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Field&lt;/th&gt;
                &lt;th&gt;Value&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;
                &lt;td&gt;First Name&lt;/td&gt;
                &lt;td&gt;${maps.get(&apos;First Name&apos;)}&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Last Name&lt;/td&gt;
                &lt;td&gt;${maps.get(&apos;Last Name&apos;)}&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Date Of Birth&lt;/td&gt;
                &lt;td&gt;${hl7_json_object.date_of_birth}&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/body&gt;

&lt;/html&gt;</template>
      </properties>
      <transformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.10.0">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.10.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.10.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.10.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.10.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.10.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.10.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.10.0">
        <elements/>
      </filter>
      <transportName>Document Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="3.10.0">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>PRODUCTION</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="3.10.0">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1618169988806</time>
        <timezone>Africa/Casablanca</timezone>
      </lastModified>
      <pruningSettings>
        <archiveEnabled>true</archiveEnabled>
      </pruningSettings>
    </metadata>
    <codeTemplateLibraries>
      <codeTemplateLibrary version="3.10.0">
        <id>b9bf5e6d-03d0-4d72-8134-4c00f59d55ac</id>
        <name>Library 1</name>
        <revision>3</revision>
        <lastModified>
          <time>1617470955477</time>
          <timezone>Africa/Casablanca</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>false</includeNewChannels>
        <enabledChannelIds>
          <string>321b5cb3-a422-4341-a177-c9e1c8837702</string>
          <string>45fb1e66-c429-4fa3-8c32-5eb17e0fea06</string>
        </enabledChannelIds>
        <disabledChannelIds>
          <string>397eb3e0-62e6-43ff-aab0-6a82df4e29cd</string>
        </disabledChannelIds>
        <codeTemplates>
          <codeTemplate version="3.10.0">
            <id>1bae7546-5fe8-4c02-9d67-44c0160e757b</id>
            <name>Moment.js</name>
            <revision>3</revision>
            <lastModified>
              <time>1617450031532</time>
              <timezone>Africa/Casablanca</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() :
    typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { &apos;use strict&apos;;

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === &apos;[object Array]&apos;
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn&apos;t for
        // input != null
        return (
            input != null &amp;&amp;
            Object.prototype.toString.call(input) === &apos;[object Object]&apos;
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === &apos;number&apos; ||
            Object.prototype.toString.call(input) === &apos;[object Number]&apos;
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === &apos;[object Date]&apos;
        );
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i &lt; arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, &apos;toString&apos;)) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, &apos;valueOf&apos;)) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length &gt;&gt;&gt; 0,
                i;

            for (i = 0; i &lt; len; i++) {
                if (i in t &amp;&amp; fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &amp;&amp;
                    flags.overflow &lt; 0 &amp;&amp;
                    !flags.empty &amp;&amp;
                    !flags.invalidEra &amp;&amp;
                    !flags.invalidMonth &amp;&amp;
                    !flags.invalidWeekday &amp;&amp;
                    !flags.weekdayMismatch &amp;&amp;
                    !flags.nullInput &amp;&amp;
                    !flags.invalidFormat &amp;&amp;
                    !flags.userInvalidated &amp;&amp;
                    (!flags.meridiem || (flags.meridiem &amp;&amp; parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &amp;&amp;
                    flags.charsLeftOver === 0 &amp;&amp;
                    flags.unusedTokens.length === 0 &amp;&amp;
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length &gt; 0) {
            for (i = 0; i &lt; momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null &amp;&amp; obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &amp;&amp;
            typeof console !== &apos;undefined&apos; &amp;&amp;
            console.warn
        ) {
            console.warn(&apos;Deprecation warning: &apos; + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i &lt; arguments.length; i++) {
                    arg = &apos;&apos;;
                    if (typeof arguments[i] === &apos;object&apos;) {
                        arg += &apos;\n[&apos; + i + &apos;] &apos;;
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + &apos;: &apos; + arguments[0][key] + &apos;, &apos;;
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        &apos;\nArguments: &apos; +
                        Array.prototype.slice.call(args).join(&apos;&apos;) +
                        &apos;\n&apos; +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== &apos;undefined&apos; &amp;&amp; input instanceof Function) ||
            Object.prototype.toString.call(input) === &apos;[object Function]&apos;
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this[&apos;_&apos; + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                &apos;|&apos; +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) &amp;&amp; isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &amp;&amp;
                !hasOwnProp(childConfig, prop) &amp;&amp;
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don&apos;t modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: &apos;[Today at] LT&apos;,
        nextDay: &apos;[Tomorrow at] LT&apos;,
        nextWeek: &apos;dddd [at] LT&apos;,
        lastDay: &apos;[Yesterday at] LT&apos;,
        lastWeek: &apos;[Last] dddd [at] LT&apos;,
        sameElse: &apos;L&apos;,
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar[&apos;sameElse&apos;];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = &apos;&apos; + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number &gt;= 0;
        return (
            (sign ? (forceSign ? &apos;+&apos; : &apos;&apos;) : &apos;-&apos;) +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    &apos;M&apos;
    // padded:   [&apos;MM&apos;, 2]
    // ordinal:  &apos;Mo&apos;
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === &apos;string&apos;) {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, &apos;&apos;);
        }
        return input.replace(/\\/g, &apos;&apos;);
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i &lt; length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = &apos;&apos;,
                i;
            for (i = 0; i &lt; length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: &apos;h:mm:ss A&apos;,
        LT: &apos;h:mm A&apos;,
        L: &apos;MM/DD/YYYY&apos;,
        LL: &apos;MMMM D, YYYY&apos;,
        LLL: &apos;MMMM D, YYYY h:mm A&apos;,
        LLLL: &apos;dddd, MMMM D, YYYY h:mm A&apos;,
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === &apos;MMMM&apos; ||
                    tok === &apos;MM&apos; ||
                    tok === &apos;DD&apos; ||
                    tok === &apos;dddd&apos;
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join(&apos;&apos;);

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = &apos;Invalid date&apos;;

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = &apos;%d&apos;,
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace(&apos;%d&apos;, number);
    }

    var defaultRelativeTime = {
        future: &apos;in %s&apos;,
        past: &apos;%s ago&apos;,
        s: &apos;a few seconds&apos;,
        ss: &apos;%d seconds&apos;,
        m: &apos;a minute&apos;,
        mm: &apos;%d minutes&apos;,
        h: &apos;an hour&apos;,
        hh: &apos;%d hours&apos;,
        d: &apos;a day&apos;,
        dd: &apos;%d days&apos;,
        w: &apos;a week&apos;,
        ww: &apos;%d weeks&apos;,
        M: &apos;a month&apos;,
        MM: &apos;%d months&apos;,
        y: &apos;a year&apos;,
        yy: &apos;%d years&apos;,
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff &gt; 0 ? &apos;future&apos; : &apos;past&apos;];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + &apos;s&apos;] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === &apos;string&apos;
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number &lt; 0) {
            // -0 -&gt; 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d[&apos;get&apos; + (mom._isUTC ? &apos;UTC&apos; : &apos;&apos;) + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() &amp;&amp; !isNaN(value)) {
            if (
                unit === &apos;FullYear&apos; &amp;&amp;
                isLeapYear(mom.year()) &amp;&amp;
                mom.month() === 1 &amp;&amp;
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d[&apos;set&apos; + (mom._isUTC ? &apos;UTC&apos; : &apos;&apos;) + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d[&apos;set&apos; + (mom._isUTC ? &apos;UTC&apos; : &apos;&apos;) + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === &apos;object&apos;) {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i &lt; prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}[&apos;a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict &amp;&amp; strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace(&apos;\\&apos;, &apos;&apos;)
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                    matched,
                    p1,
                    p2,
                    p3,
                    p4
                ) {
                    return p1 || p2 || p3 || p4;
                })
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, &apos;\\$&amp;&apos;);
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === &apos;string&apos;) {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i &lt; token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null &amp;&amp; hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i &lt; this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken(&apos;M&apos;, [&apos;MM&apos;, 2], &apos;Mo&apos;, function () {
        return this.month() + 1;
    });

    addFormatToken(&apos;MMM&apos;, 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken(&apos;MMMM&apos;, 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias(&apos;month&apos;, &apos;M&apos;);

    // PRIORITY

    addUnitPriority(&apos;month&apos;, 8);

    // PARSING

    addRegexToken(&apos;M&apos;, match1to2);
    addRegexToken(&apos;MM&apos;, match1to2, match2);
    addRegexToken(&apos;MMM&apos;, function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken(&apos;MMMM&apos;, function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken([&apos;M&apos;, &apos;MM&apos;], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken([&apos;MMM&apos;, &apos;MMMM&apos;], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn&apos;t find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = &apos;January_February_March_April_May_June_July_August_September_October_November_December&apos;.split(
            &apos;_&apos;
        ),
        defaultLocaleMonthsShort = &apos;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&apos;.split(
            &apos;_&apos;
        ),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months[&apos;standalone&apos;];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? &apos;format&apos;
                      : &apos;standalone&apos;
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort[&apos;standalone&apos;];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? &apos;format&apos; : &apos;standalone&apos;
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i &lt; 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    &apos;&apos;
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, &apos;&apos;).toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === &apos;MMM&apos;) {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === &apos;MMM&apos;) {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i &lt; 12; i++) {
            // make the regex if we don&apos;t have it already
            mom = createUTC([2000, i]);
            if (strict &amp;&amp; !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    &apos;^&apos; + this.months(mom, &apos;&apos;).replace(&apos;.&apos;, &apos;&apos;) + &apos;$&apos;,
                    &apos;i&apos;
                );
                this._shortMonthsParse[i] = new RegExp(
                    &apos;^&apos; + this.monthsShort(mom, &apos;&apos;).replace(&apos;.&apos;, &apos;&apos;) + &apos;$&apos;,
                    &apos;i&apos;
                );
            }
            if (!strict &amp;&amp; !this._monthsParse[i]) {
                regex =
                    &apos;^&apos; + this.months(mom, &apos;&apos;) + &apos;|^&apos; + this.monthsShort(mom, &apos;&apos;);
                this._monthsParse[i] = new RegExp(regex.replace(&apos;.&apos;, &apos;&apos;), &apos;i&apos;);
            }
            // test the regex
            if (
                strict &amp;&amp;
                format === &apos;MMMM&apos; &amp;&amp;
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &amp;&amp;
                format === &apos;MMM&apos; &amp;&amp;
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === &apos;string&apos;) {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d[&apos;set&apos; + (mom._isUTC ? &apos;UTC&apos; : &apos;&apos;) + &apos;Month&apos;](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, &apos;Month&apos;);
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, &apos;_monthsRegex&apos;)) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, &apos;_monthsShortRegex&apos;)) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex &amp;&amp; isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, &apos;_monthsRegex&apos;)) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, &apos;_monthsRegex&apos;)) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex &amp;&amp; isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i &lt; 12; i++) {
            // make the regex if we don&apos;t have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, &apos;&apos;));
            longPieces.push(this.months(mom, &apos;&apos;));
            mixedPieces.push(this.months(mom, &apos;&apos;));
            mixedPieces.push(this.monthsShort(mom, &apos;&apos;));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i &lt; 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i &lt; 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp(&apos;^(&apos; + mixedPieces.join(&apos;|&apos;) + &apos;)&apos;, &apos;i&apos;);
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            &apos;^(&apos; + longPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
        this._monthsShortStrictRegex = new RegExp(
            &apos;^(&apos; + shortPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
    }

    // FORMATTING

    addFormatToken(&apos;Y&apos;, 0, 0, function () {
        var y = this.year();
        return y &lt;= 9999 ? zeroFill(y, 4) : &apos;+&apos; + y;
    });

    addFormatToken(0, [&apos;YY&apos;, 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, [&apos;YYYY&apos;, 4], 0, &apos;year&apos;);
    addFormatToken(0, [&apos;YYYYY&apos;, 5], 0, &apos;year&apos;);
    addFormatToken(0, [&apos;YYYYYY&apos;, 6, true], 0, &apos;year&apos;);

    // ALIASES

    addUnitAlias(&apos;year&apos;, &apos;y&apos;);

    // PRIORITIES

    addUnitPriority(&apos;year&apos;, 1);

    // PARSING

    addRegexToken(&apos;Y&apos;, matchSigned);
    addRegexToken(&apos;YY&apos;, match1to2, match2);
    addRegexToken(&apos;YYYY&apos;, match1to4, match4);
    addRegexToken(&apos;YYYYY&apos;, match1to6, match6);
    addRegexToken(&apos;YYYYYY&apos;, match1to6, match6);

    addParseToken([&apos;YYYYY&apos;, &apos;YYYYYY&apos;], YEAR);
    addParseToken(&apos;YYYY&apos;, function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken(&apos;YY&apos;, function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken(&apos;Y&apos;, function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet(&apos;FullYear&apos;, true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can&apos;t just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y &lt; 100 &amp;&amp; y &gt;= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y &lt; 100 &amp;&amp; y &gt;= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear &lt;= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear &gt; daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week &lt; 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week &gt; weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken(&apos;w&apos;, [&apos;ww&apos;, 2], &apos;wo&apos;, &apos;week&apos;);
    addFormatToken(&apos;W&apos;, [&apos;WW&apos;, 2], &apos;Wo&apos;, &apos;isoWeek&apos;);

    // ALIASES

    addUnitAlias(&apos;week&apos;, &apos;w&apos;);
    addUnitAlias(&apos;isoWeek&apos;, &apos;W&apos;);

    // PRIORITIES

    addUnitPriority(&apos;week&apos;, 5);
    addUnitPriority(&apos;isoWeek&apos;, 5);

    // PARSING

    addRegexToken(&apos;w&apos;, match1to2);
    addRegexToken(&apos;ww&apos;, match1to2, match2);
    addRegexToken(&apos;W&apos;, match1to2);
    addRegexToken(&apos;WW&apos;, match1to2, match2);

    addWeekParseToken([&apos;w&apos;, &apos;ww&apos;, &apos;W&apos;, &apos;WW&apos;], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, &apos;d&apos;);
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, &apos;d&apos;);
    }

    // FORMATTING

    addFormatToken(&apos;d&apos;, 0, &apos;do&apos;, &apos;day&apos;);

    addFormatToken(&apos;dd&apos;, 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken(&apos;ddd&apos;, 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken(&apos;dddd&apos;, 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken(&apos;e&apos;, 0, 0, &apos;weekday&apos;);
    addFormatToken(&apos;E&apos;, 0, 0, &apos;isoWeekday&apos;);

    // ALIASES

    addUnitAlias(&apos;day&apos;, &apos;d&apos;);
    addUnitAlias(&apos;weekday&apos;, &apos;e&apos;);
    addUnitAlias(&apos;isoWeekday&apos;, &apos;E&apos;);

    // PRIORITY
    addUnitPriority(&apos;day&apos;, 11);
    addUnitPriority(&apos;weekday&apos;, 11);
    addUnitPriority(&apos;isoWeekday&apos;, 11);

    // PARSING

    addRegexToken(&apos;d&apos;, match1to2);
    addRegexToken(&apos;e&apos;, match1to2);
    addRegexToken(&apos;E&apos;, match1to2);
    addRegexToken(&apos;dd&apos;, function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken(&apos;ddd&apos;, function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken(&apos;dddd&apos;, function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken([&apos;dd&apos;, &apos;ddd&apos;, &apos;dddd&apos;], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn&apos;t get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken([&apos;d&apos;, &apos;e&apos;, &apos;E&apos;], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== &apos;string&apos;) {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === &apos;number&apos;) {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === &apos;string&apos;) {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = &apos;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&apos;.split(
            &apos;_&apos;
        ),
        defaultLocaleWeekdaysShort = &apos;Sun_Mon_Tue_Wed_Thu_Fri_Sat&apos;.split(&apos;_&apos;),
        defaultLocaleWeekdaysMin = &apos;Su_Mo_Tu_We_Th_Fr_Sa&apos;.split(&apos;_&apos;),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m &amp;&amp; m !== true &amp;&amp; this._weekdays.isFormat.test(format)
                      ? &apos;format&apos;
                      : &apos;standalone&apos;
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i &lt; 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    &apos;&apos;
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    &apos;&apos;
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, &apos;&apos;).toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === &apos;dddd&apos;) {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === &apos;ddd&apos;) {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === &apos;dddd&apos;) {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === &apos;ddd&apos;) {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i &lt; 7; i++) {
            // make the regex if we don&apos;t have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict &amp;&amp; !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    &apos;^&apos; + this.weekdays(mom, &apos;&apos;).replace(&apos;.&apos;, &apos;\\.?&apos;) + &apos;$&apos;,
                    &apos;i&apos;
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    &apos;^&apos; + this.weekdaysShort(mom, &apos;&apos;).replace(&apos;.&apos;, &apos;\\.?&apos;) + &apos;$&apos;,
                    &apos;i&apos;
                );
                this._minWeekdaysParse[i] = new RegExp(
                    &apos;^&apos; + this.weekdaysMin(mom, &apos;&apos;).replace(&apos;.&apos;, &apos;\\.?&apos;) + &apos;$&apos;,
                    &apos;i&apos;
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    &apos;^&apos; +
                    this.weekdays(mom, &apos;&apos;) +
                    &apos;|^&apos; +
                    this.weekdaysShort(mom, &apos;&apos;) +
                    &apos;|^&apos; +
                    this.weekdaysMin(mom, &apos;&apos;);
                this._weekdaysParse[i] = new RegExp(regex.replace(&apos;.&apos;, &apos;&apos;), &apos;i&apos;);
            }
            // test the regex
            if (
                strict &amp;&amp;
                format === &apos;dddd&apos; &amp;&amp;
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &amp;&amp;
                format === &apos;ddd&apos; &amp;&amp;
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &amp;&amp;
                format === &apos;dd&apos; &amp;&amp;
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict &amp;&amp; this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, &apos;d&apos;);
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, &apos;d&apos;);
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, &apos;_weekdaysRegex&apos;)) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, &apos;_weekdaysRegex&apos;)) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex &amp;&amp; isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, &apos;_weekdaysRegex&apos;)) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, &apos;_weekdaysShortRegex&apos;)) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex &amp;&amp; isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, &apos;_weekdaysRegex&apos;)) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, &apos;_weekdaysMinRegex&apos;)) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex &amp;&amp; isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i &lt; 7; i++) {
            // make the regex if we don&apos;t have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, &apos;&apos;));
            shortp = regexEscape(this.weekdaysShort(mom, &apos;&apos;));
            longp = regexEscape(this.weekdays(mom, &apos;&apos;));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp(&apos;^(&apos; + mixedPieces.join(&apos;|&apos;) + &apos;)&apos;, &apos;i&apos;);
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            &apos;^(&apos; + longPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
        this._weekdaysShortStrictRegex = new RegExp(
            &apos;^(&apos; + shortPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
        this._weekdaysMinStrictRegex = new RegExp(
            &apos;^(&apos; + minPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken(&apos;H&apos;, [&apos;HH&apos;, 2], 0, &apos;hour&apos;);
    addFormatToken(&apos;h&apos;, [&apos;hh&apos;, 2], 0, hFormat);
    addFormatToken(&apos;k&apos;, [&apos;kk&apos;, 2], 0, kFormat);

    addFormatToken(&apos;hmm&apos;, 0, 0, function () {
        return &apos;&apos; + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken(&apos;hmmss&apos;, 0, 0, function () {
        return (
            &apos;&apos; +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken(&apos;Hmm&apos;, 0, 0, function () {
        return &apos;&apos; + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken(&apos;Hmmss&apos;, 0, 0, function () {
        return (
            &apos;&apos; +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem(&apos;a&apos;, true);
    meridiem(&apos;A&apos;, false);

    // ALIASES

    addUnitAlias(&apos;hour&apos;, &apos;h&apos;);

    // PRIORITY
    addUnitPriority(&apos;hour&apos;, 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken(&apos;a&apos;, matchMeridiem);
    addRegexToken(&apos;A&apos;, matchMeridiem);
    addRegexToken(&apos;H&apos;, match1to2);
    addRegexToken(&apos;h&apos;, match1to2);
    addRegexToken(&apos;k&apos;, match1to2);
    addRegexToken(&apos;HH&apos;, match1to2, match2);
    addRegexToken(&apos;hh&apos;, match1to2, match2);
    addRegexToken(&apos;kk&apos;, match1to2, match2);

    addRegexToken(&apos;hmm&apos;, match3to4);
    addRegexToken(&apos;hmmss&apos;, match5to6);
    addRegexToken(&apos;Hmm&apos;, match3to4);
    addRegexToken(&apos;Hmmss&apos;, match5to6);

    addParseToken([&apos;H&apos;, &apos;HH&apos;], HOUR);
    addParseToken([&apos;k&apos;, &apos;kk&apos;], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken([&apos;a&apos;, &apos;A&apos;], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([&apos;h&apos;, &apos;hh&apos;], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken(&apos;hmm&apos;, function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken(&apos;hmmss&apos;, function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken(&apos;Hmm&apos;, function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken(&apos;Hmmss&apos;, function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + &apos;&apos;).toLowerCase().charAt(0) === &apos;p&apos;;
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet(&apos;Hours&apos;, true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours &gt; 11) {
            return isLower ? &apos;pm&apos; : &apos;PM&apos;;
        } else {
            return isLower ? &apos;am&apos; : &apos;AM&apos;;
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i &lt; minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace(&apos;_&apos;, &apos;-&apos;) : key;
    }

    // pick the locale from the array
    // try [&apos;en-au&apos;, &apos;en-gb&apos;] as &apos;en-au&apos;, &apos;en-gb&apos;, &apos;en&apos;, as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it&apos;s a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i &lt; names.length) {
            split = normalizeLocale(names[i]).split(&apos;-&apos;);
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split(&apos;-&apos;) : null;
            while (j &gt; 0) {
                locale = loadLocale(split.slice(0, j).join(&apos;-&apos;));
                if (locale) {
                    return locale;
                }
                if (
                    next &amp;&amp;
                    next.length &gt;= j &amp;&amp;
                    commonPrefix(split, next) &gt;= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &amp;&amp;
            typeof module !== &apos;undefined&apos; &amp;&amp;
            module &amp;&amp;
            module.exports
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire(&apos;./locale/&apos; + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== &apos;undefined&apos; &amp;&amp; console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        &apos;Locale &apos; + key + &apos; not found. Did you forget to load it?&apos;
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    &apos;defineLocaleOverride&apos;,
                    &apos;use moment.updateLocale(localeName, config) to change &apos; +
                        &apos;an existing locale. moment.defineLocale(localeName, &apos; +
                        &apos;config) should only be used for creating a new locale &apos; +
                        &apos;See http://momentjs.com/guides/#/warnings/define-locale/ for more info.&apos;
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won&apos;t end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null &amp;&amp; locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a &amp;&amp; getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] &lt; 0 || a[MONTH] &gt; 11
                    ? MONTH
                    : a[DATE] &lt; 1 || a[DATE] &gt; daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] &lt; 0 ||
                      a[HOUR] &gt; 24 ||
                      (a[HOUR] === 24 &amp;&amp;
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] &lt; 0 || a[MINUTE] &gt; 59
                    ? MINUTE
                    : a[SECOND] &lt; 0 || a[SECOND] &gt; 59
                    ? SECOND
                    : a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &amp;&amp;
                (overflow &lt; YEAR || overflow &gt; DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks &amp;&amp; overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday &amp;&amp; overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            [&apos;YYYYYY-MM-DD&apos;, /[+-]\d{6}-\d\d-\d\d/],
            [&apos;YYYY-MM-DD&apos;, /\d{4}-\d\d-\d\d/],
            [&apos;GGGG-[W]WW-E&apos;, /\d{4}-W\d\d-\d/],
            [&apos;GGGG-[W]WW&apos;, /\d{4}-W\d\d/, false],
            [&apos;YYYY-DDD&apos;, /\d{4}-\d{3}/],
            [&apos;YYYY-MM&apos;, /\d{4}-\d\d/, false],
            [&apos;YYYYYYMMDD&apos;, /[+-]\d{10}/],
            [&apos;YYYYMMDD&apos;, /\d{8}/],
            [&apos;GGGG[W]WWE&apos;, /\d{4}W\d{3}/],
            [&apos;GGGG[W]WW&apos;, /\d{4}W\d{2}/, false],
            [&apos;YYYYDDD&apos;, /\d{7}/],
            [&apos;YYYYMM&apos;, /\d{6}/, false],
            [&apos;YYYY&apos;, /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            [&apos;HH:mm:ss.SSSS&apos;, /\d\d:\d\d:\d\d\.\d+/],
            [&apos;HH:mm:ss,SSSS&apos;, /\d\d:\d\d:\d\d,\d+/],
            [&apos;HH:mm:ss&apos;, /\d\d:\d\d:\d\d/],
            [&apos;HH:mm&apos;, /\d\d:\d\d/],
            [&apos;HHmmss.SSSS&apos;, /\d\d\d\d\d\d\.\d+/],
            [&apos;HHmmss,SSSS&apos;, /\d\d\d\d\d\d,\d+/],
            [&apos;HHmmss&apos;, /\d\d\d\d\d\d/],
            [&apos;HHmm&apos;, /\d\d\d\d/],
            [&apos;HH&apos;, /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i &lt; l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i &lt; l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be &apos;T&apos; or space
                        timeFormat = (match[2] || &apos; &apos;) + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime &amp;&amp; timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = &apos;Z&apos;;
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || &apos;&apos;) + (tzFormat || &apos;&apos;);
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year &lt;= 49) {
            return 2000 + year;
        } else if (year &lt;= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^)]*\)|[\n\t]/g, &apos; &apos;)
            .replace(/(\s\s+)/g, &apos; &apos;)
            .replace(/^\s\s*/, &apos;&apos;)
            .replace(/\s\s*$/, &apos;&apos;);
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn&apos;t strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        &apos;value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), &apos; +
            &apos;which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are &apos; +
            &apos;discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.&apos;,
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? &apos; UTC&apos; : &apos;&apos;));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear &gt; daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don&apos;t default anything
        for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i &lt; 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &amp;&amp;
            config._a[MINUTE] === 0 &amp;&amp;
            config._a[SECOND] === 0 &amp;&amp;
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &amp;&amp;
            typeof config._w.d !== &apos;undefined&apos; &amp;&amp;
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday &lt; 1 || weekday &gt; 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday &lt; 0 || weekday &gt; 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e &lt; 0 || w.e &gt; 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week &lt; 1 || week &gt; weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = &apos;&apos; + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i &lt; tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length &gt; 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don&apos;t parse if it&apos;s not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict &amp;&amp; !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length &gt; 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is &lt;= 12
        if (
            config._a[HOUR] &lt;= 12 &amp;&amp;
            getParsingFlags(config).bigHour === true &amp;&amp;
            config._a[HOUR] &gt; 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm &amp;&amp; hour &lt; 12) {
                hour += 12;
            }
            if (!isPm &amp;&amp; hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i &lt; config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore &lt; scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore &lt; scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj &amp;&amp; parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, &apos;d&apos;);
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined &amp;&amp; input === &apos;&apos;)) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === &apos;string&apos;) {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === &apos;string&apos;) {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) &amp;&amp; isObjectEmpty(input)) ||
            (isArray(input) &amp;&amp; input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            &apos;moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/&apos;,
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() &amp;&amp; other.isValid()) {
                    return other &lt; this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            &apos;moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/&apos;,
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() &amp;&amp; other.isValid()) {
                    return other &gt; this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i &lt; moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy(&apos;isBefore&apos;, args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy(&apos;isAfter&apos;, args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        &apos;year&apos;,
        &apos;quarter&apos;,
        &apos;month&apos;,
        &apos;week&apos;,
        &apos;day&apos;,
        &apos;hour&apos;,
        &apos;minute&apos;,
        &apos;second&apos;,
        &apos;millisecond&apos;,
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (
                hasOwnProp(m, key) &amp;&amp;
                !(
                    indexOf.call(ordering, key) !== -1 &amp;&amp;
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i &lt; ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number &lt; 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i &lt; len; i++) {
            if (
                (dontConvert &amp;&amp; array1[i] !== array2[i]) ||
                (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = &apos;+&apos;;
            if (offset &lt; 0) {
                offset = -offset;
                sign = &apos;-&apos;;
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset(&apos;Z&apos;, &apos;:&apos;);
    offset(&apos;ZZ&apos;, &apos;&apos;);

    // PARSING

    addRegexToken(&apos;Z&apos;, matchShortOffset);
    addRegexToken(&apos;ZZ&apos;, matchShortOffset);
    addParseToken([&apos;Z&apos;, &apos;ZZ&apos;], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // &apos;+10:00&apos; &gt; [&apos;10&apos;,  &apos;00&apos;]
    // &apos;-1530&apos;  &gt; [&apos;-15&apos;, &apos;30&apos;]
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || &apos;&apos;).match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + &apos;&apos;).match(chunkOffset) || [&apos;-&apos;, 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === &apos;+&apos; ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
    // 5:31:26 +0200 It is possible that 5:31:26 doesn&apos;t exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === &apos;string&apos;) {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) &lt; 16 &amp;&amp; !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC &amp;&amp; keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, &apos;m&apos;);
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, &apos;m&apos;),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== &apos;string&apos;) {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), &apos;m&apos;);
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === &apos;string&apos;) {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
            this.utcOffset() &gt; this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() &amp;&amp; compareArrays(c._a, other.toArray()) &gt; 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC &amp;&amp; this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === &apos;-&apos; ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === &apos;-&apos; ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === &apos;object&apos; &amp;&amp;
            (&apos;from&apos; in duration || &apos;to&apos; in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) &amp;&amp; hasOwnProp(input, &apos;_locale&apos;)) {
            ret._locale = input._locale;
        }

        if (isDuration(input) &amp;&amp; hasOwnProp(input, &apos;_isValid&apos;)) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We&apos;d normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp &amp;&amp; parseFloat(inp.replace(&apos;,&apos;, &apos;.&apos;));
        // apply sign while we&apos;re at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, &apos;M&apos;).isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, &apos;M&apos;);

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() &amp;&amp; other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove &apos;name&apos; arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null &amp;&amp; !isNaN(+period)) {
                deprecateSimple(
                    name,
                    &apos;moment().&apos; +
                        name +
                        &apos;(period, number) is deprecated. Please use moment().&apos; +
                        name +
                        &apos;(number, period). &apos; +
                        &apos;See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.&apos;
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, &apos;Month&apos;) + months * isAdding);
        }
        if (days) {
            set$1(mom, &apos;Date&apos;, get(mom, &apos;Date&apos;) + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, &apos;add&apos;),
        subtract = createAdder(-1, &apos;subtract&apos;);

    function isString(input) {
        return typeof input === &apos;string&apos; || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) &amp;&amp; !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                &apos;years&apos;,
                &apos;year&apos;,
                &apos;y&apos;,
                &apos;months&apos;,
                &apos;month&apos;,
                &apos;M&apos;,
                &apos;days&apos;,
                &apos;day&apos;,
                &apos;d&apos;,
                &apos;dates&apos;,
                &apos;date&apos;,
                &apos;D&apos;,
                &apos;hours&apos;,
                &apos;hour&apos;,
                &apos;h&apos;,
                &apos;minutes&apos;,
                &apos;minute&apos;,
                &apos;m&apos;,
                &apos;seconds&apos;,
                &apos;second&apos;,
                &apos;s&apos;,
                &apos;milliseconds&apos;,
                &apos;millisecond&apos;,
                &apos;ms&apos;,
            ],
            i,
            property;

        for (i = 0; i &lt; properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest &amp;&amp; propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) &amp;&amp; isString(input);
                }).length === 0;
        }
        return arrayTest &amp;&amp; dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) &amp;&amp; !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                &apos;sameDay&apos;,
                &apos;nextDay&apos;,
                &apos;lastDay&apos;,
                &apos;nextWeek&apos;,
                &apos;lastWeek&apos;,
                &apos;sameElse&apos;,
            ],
            i,
            property;

        for (i = 0; i &lt; properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest &amp;&amp; propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, &apos;days&apos;, true);
        return diff &lt; -6
            ? &apos;sameElse&apos;
            : diff &lt; -1
            ? &apos;lastWeek&apos;
            : diff &lt; 0
            ? &apos;lastDay&apos;
            : diff &lt; 1
            ? &apos;sameDay&apos;
            : diff &lt; 2
            ? &apos;nextDay&apos;
            : diff &lt; 7
            ? &apos;nextWeek&apos;
            : &apos;sameElse&apos;;
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we&apos;re local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf(&apos;day&apos;),
            format = hooks.calendarFormat(this, sod) || &apos;sameElse&apos;,
            output =
                formats &amp;&amp;
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() &amp;&amp; localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || &apos;millisecond&apos;;
        if (units === &apos;millisecond&apos;) {
            return this.valueOf() &gt; localInput.valueOf();
        } else {
            return localInput.valueOf() &lt; this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() &amp;&amp; localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || &apos;millisecond&apos;;
        if (units === &apos;millisecond&apos;) {
            return this.valueOf() &lt; localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() &lt; localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() &amp;&amp; localFrom.isValid() &amp;&amp; localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || &apos;()&apos;;
        return (
            (inclusivity[0] === &apos;(&apos;
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &amp;&amp;
            (inclusivity[1] === &apos;)&apos;
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() &amp;&amp; localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || &apos;millisecond&apos;;
        if (units === &apos;millisecond&apos;) {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() &lt;= inputMs &amp;&amp;
                inputMs &lt;= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case &apos;year&apos;:
                output = monthDiff(this, that) / 12;
                break;
            case &apos;month&apos;:
                output = monthDiff(this, that);
                break;
            case &apos;quarter&apos;:
                output = monthDiff(this, that) / 3;
                break;
            case &apos;second&apos;:
                output = (this - that) / 1e3;
                break; // 1000
            case &apos;minute&apos;:
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case &apos;hour&apos;:
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case &apos;day&apos;:
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case &apos;week&apos;:
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() &lt; b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, &apos;months&apos;),
            anchor2,
            adjust;

        if (b - anchor &lt; 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, &apos;months&apos;);
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, &apos;months&apos;);
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = &apos;YYYY-MM-DDTHH:mm:ssZ&apos;;
    hooks.defaultFormatUtc = &apos;YYYY-MM-DDTHH:mm:ss[Z]&apos;;

    function toString() {
        return this.clone().locale(&apos;en&apos;).format(&apos;ddd MMM DD YYYY HH:mm:ss [GMT]ZZ&apos;);
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() &lt; 0 || m.year() &gt; 9999) {
            return formatMoment(
                m,
                utc
                    ? &apos;YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]&apos;
                    : &apos;YYYYYY-MM-DD[T]HH:mm:ss.SSSZ&apos;
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace(&apos;Z&apos;, formatMoment(m, &apos;Z&apos;));
            }
        }
        return formatMoment(
            m,
            utc ? &apos;YYYY-MM-DD[T]HH:mm:ss.SSS[Z]&apos; : &apos;YYYY-MM-DD[T]HH:mm:ss.SSSZ&apos;
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return &apos;moment.invalid(/* &apos; + this._i + &apos; */)&apos;;
        }
        var func = &apos;moment&apos;,
            zone = &apos;&apos;,
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? &apos;moment.utc&apos; : &apos;moment.parseZone&apos;;
            zone = &apos;Z&apos;;
        }
        prefix = &apos;[&apos; + func + &apos;(&quot;]&apos;;
        year = 0 &lt;= this.year() &amp;&amp; this.year() &lt;= 9999 ? &apos;YYYY&apos; : &apos;YYYYYY&apos;;
        datetime = &apos;-MM-DD[T]HH:mm:ss.SSS&apos;;
        suffix = zone + &apos;[&quot;)]&apos;;

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &amp;&amp;
            ((isMoment(time) &amp;&amp; time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &amp;&amp;
            ((isMoment(time) &amp;&amp; time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        &apos;moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.&apos;,
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y &lt; 100 &amp;&amp; y &gt;= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y &lt; 100 &amp;&amp; y &gt;= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === &apos;millisecond&apos; || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case &apos;year&apos;:
                time = startOfDate(this.year(), 0, 1);
                break;
            case &apos;quarter&apos;:
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case &apos;month&apos;:
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case &apos;week&apos;:
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case &apos;isoWeek&apos;:
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case &apos;day&apos;:
            case &apos;date&apos;:
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case &apos;hour&apos;:
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case &apos;minute&apos;:
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case &apos;second&apos;:
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === &apos;millisecond&apos; || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case &apos;year&apos;:
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case &apos;quarter&apos;:
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case &apos;month&apos;:
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case &apos;week&apos;:
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case &apos;isoWeek&apos;:
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case &apos;day&apos;:
            case &apos;date&apos;:
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case &apos;hour&apos;:
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case &apos;minute&apos;:
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case &apos;second&apos;:
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken(&apos;N&apos;, 0, 0, &apos;eraAbbr&apos;);
    addFormatToken(&apos;NN&apos;, 0, 0, &apos;eraAbbr&apos;);
    addFormatToken(&apos;NNN&apos;, 0, 0, &apos;eraAbbr&apos;);
    addFormatToken(&apos;NNNN&apos;, 0, 0, &apos;eraName&apos;);
    addFormatToken(&apos;NNNNN&apos;, 0, 0, &apos;eraNarrow&apos;);

    addFormatToken(&apos;y&apos;, [&apos;y&apos;, 1], &apos;yo&apos;, &apos;eraYear&apos;);
    addFormatToken(&apos;y&apos;, [&apos;yy&apos;, 2], 0, &apos;eraYear&apos;);
    addFormatToken(&apos;y&apos;, [&apos;yyy&apos;, 3], 0, &apos;eraYear&apos;);
    addFormatToken(&apos;y&apos;, [&apos;yyyy&apos;, 4], 0, &apos;eraYear&apos;);

    addRegexToken(&apos;N&apos;, matchEraAbbr);
    addRegexToken(&apos;NN&apos;, matchEraAbbr);
    addRegexToken(&apos;NNN&apos;, matchEraAbbr);
    addRegexToken(&apos;NNNN&apos;, matchEraName);
    addRegexToken(&apos;NNNNN&apos;, matchEraNarrow);

    addParseToken([&apos;N&apos;, &apos;NN&apos;, &apos;NNN&apos;, &apos;NNNN&apos;, &apos;NNNNN&apos;], function (
        input,
        array,
        config,
        token
    ) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });

    addRegexToken(&apos;y&apos;, matchUnsigned);
    addRegexToken(&apos;yy&apos;, matchUnsigned);
    addRegexToken(&apos;yyy&apos;, matchUnsigned);
    addRegexToken(&apos;yyyy&apos;, matchUnsigned);
    addRegexToken(&apos;yo&apos;, matchEraYearOrdinal);

    addParseToken([&apos;y&apos;, &apos;yy&apos;, &apos;yyy&apos;, &apos;yyyy&apos;], YEAR);
    addParseToken([&apos;yo&apos;], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale(&apos;en&apos;)._eras;
        for (i = 0, l = eras.length; i &lt; l; ++i) {
            switch (typeof eras[i].since) {
                case &apos;string&apos;:
                    // truncate time
                    date = hooks(eras[i].since).startOf(&apos;day&apos;);
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case &apos;undefined&apos;:
                    eras[i].until = +Infinity;
                    break;
                case &apos;string&apos;:
                    // truncate time
                    date = hooks(eras[i].until).startOf(&apos;day&apos;).valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i &lt; l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case &apos;N&apos;:
                    case &apos;NN&apos;:
                    case &apos;NNN&apos;:
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case &apos;NNNN&apos;:
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case &apos;NNNNN&apos;:
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) &gt;= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since &lt;= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i &lt; l; ++i) {
            // truncate time
            val = this.clone().startOf(&apos;day&apos;).valueOf();

            if (eras[i].since &lt;= val &amp;&amp; val &lt;= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until &lt;= val &amp;&amp; val &lt;= eras[i].since) {
                return eras[i].name;
            }
        }

        return &apos;&apos;;
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i &lt; l; ++i) {
            // truncate time
            val = this.clone().startOf(&apos;day&apos;).valueOf();

            if (eras[i].since &lt;= val &amp;&amp; val &lt;= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until &lt;= val &amp;&amp; val &lt;= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return &apos;&apos;;
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i &lt; l; ++i) {
            // truncate time
            val = this.clone().startOf(&apos;day&apos;).valueOf();

            if (eras[i].since &lt;= val &amp;&amp; val &lt;= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until &lt;= val &amp;&amp; val &lt;= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return &apos;&apos;;
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i &lt; l; ++i) {
            dir = eras[i].since &lt;= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf(&apos;day&apos;).valueOf();

            if (
                (eras[i].since &lt;= val &amp;&amp; val &lt;= eras[i].until) ||
                (eras[i].until &lt;= val &amp;&amp; val &lt;= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, &apos;_erasNameRegex&apos;)) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, &apos;_erasAbbrRegex&apos;)) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, &apos;_erasNarrowRegex&apos;)) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i &lt; l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp(&apos;^(&apos; + mixedPieces.join(&apos;|&apos;) + &apos;)&apos;, &apos;i&apos;);
        this._erasNameRegex = new RegExp(&apos;^(&apos; + namePieces.join(&apos;|&apos;) + &apos;)&apos;, &apos;i&apos;);
        this._erasAbbrRegex = new RegExp(&apos;^(&apos; + abbrPieces.join(&apos;|&apos;) + &apos;)&apos;, &apos;i&apos;);
        this._erasNarrowRegex = new RegExp(
            &apos;^(&apos; + narrowPieces.join(&apos;|&apos;) + &apos;)&apos;,
            &apos;i&apos;
        );
    }

    // FORMATTING

    addFormatToken(0, [&apos;gg&apos;, 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, [&apos;GG&apos;, 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken(&apos;gggg&apos;, &apos;weekYear&apos;);
    addWeekYearFormatToken(&apos;ggggg&apos;, &apos;weekYear&apos;);
    addWeekYearFormatToken(&apos;GGGG&apos;, &apos;isoWeekYear&apos;);
    addWeekYearFormatToken(&apos;GGGGG&apos;, &apos;isoWeekYear&apos;);

    // ALIASES

    addUnitAlias(&apos;weekYear&apos;, &apos;gg&apos;);
    addUnitAlias(&apos;isoWeekYear&apos;, &apos;GG&apos;);

    // PRIORITY

    addUnitPriority(&apos;weekYear&apos;, 1);
    addUnitPriority(&apos;isoWeekYear&apos;, 1);

    // PARSING

    addRegexToken(&apos;G&apos;, matchSigned);
    addRegexToken(&apos;g&apos;, matchSigned);
    addRegexToken(&apos;GG&apos;, match1to2, match2);
    addRegexToken(&apos;gg&apos;, match1to2, match2);
    addRegexToken(&apos;GGGG&apos;, match1to4, match4);
    addRegexToken(&apos;gggg&apos;, match1to4, match4);
    addRegexToken(&apos;GGGGG&apos;, match1to6, match6);
    addRegexToken(&apos;ggggg&apos;, match1to6, match6);

    addWeekParseToken([&apos;gggg&apos;, &apos;ggggg&apos;, &apos;GGGG&apos;, &apos;GGGGG&apos;], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken([&apos;gg&apos;, &apos;GG&apos;], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week &gt; weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken(&apos;Q&apos;, 0, &apos;Qo&apos;, &apos;quarter&apos;);

    // ALIASES

    addUnitAlias(&apos;quarter&apos;, &apos;Q&apos;);

    // PRIORITY

    addUnitPriority(&apos;quarter&apos;, 7);

    // PARSING

    addRegexToken(&apos;Q&apos;, match1);
    addParseToken(&apos;Q&apos;, function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken(&apos;D&apos;, [&apos;DD&apos;, 2], &apos;Do&apos;, &apos;date&apos;);

    // ALIASES

    addUnitAlias(&apos;date&apos;, &apos;D&apos;);

    // PRIORITY
    addUnitPriority(&apos;date&apos;, 9);

    // PARSING

    addRegexToken(&apos;D&apos;, match1to2);
    addRegexToken(&apos;DD&apos;, match1to2, match2);
    addRegexToken(&apos;Do&apos;, function (isStrict, locale) {
        // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken([&apos;D&apos;, &apos;DD&apos;], DATE);
    addParseToken(&apos;Do&apos;, function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet(&apos;Date&apos;, true);

    // FORMATTING

    addFormatToken(&apos;DDD&apos;, [&apos;DDDD&apos;, 3], &apos;DDDo&apos;, &apos;dayOfYear&apos;);

    // ALIASES

    addUnitAlias(&apos;dayOfYear&apos;, &apos;DDD&apos;);

    // PRIORITY
    addUnitPriority(&apos;dayOfYear&apos;, 4);

    // PARSING

    addRegexToken(&apos;DDD&apos;, match1to3);
    addRegexToken(&apos;DDDD&apos;, match3);
    addParseToken([&apos;DDD&apos;, &apos;DDDD&apos;], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf(&apos;day&apos;) - this.clone().startOf(&apos;year&apos;)) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, &apos;d&apos;);
    }

    // FORMATTING

    addFormatToken(&apos;m&apos;, [&apos;mm&apos;, 2], 0, &apos;minute&apos;);

    // ALIASES

    addUnitAlias(&apos;minute&apos;, &apos;m&apos;);

    // PRIORITY

    addUnitPriority(&apos;minute&apos;, 14);

    // PARSING

    addRegexToken(&apos;m&apos;, match1to2);
    addRegexToken(&apos;mm&apos;, match1to2, match2);
    addParseToken([&apos;m&apos;, &apos;mm&apos;], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet(&apos;Minutes&apos;, false);

    // FORMATTING

    addFormatToken(&apos;s&apos;, [&apos;ss&apos;, 2], 0, &apos;second&apos;);

    // ALIASES

    addUnitAlias(&apos;second&apos;, &apos;s&apos;);

    // PRIORITY

    addUnitPriority(&apos;second&apos;, 15);

    // PARSING

    addRegexToken(&apos;s&apos;, match1to2);
    addRegexToken(&apos;ss&apos;, match1to2, match2);
    addParseToken([&apos;s&apos;, &apos;ss&apos;], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet(&apos;Seconds&apos;, false);

    // FORMATTING

    addFormatToken(&apos;S&apos;, 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, [&apos;SS&apos;, 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, [&apos;SSS&apos;, 3], 0, &apos;millisecond&apos;);
    addFormatToken(0, [&apos;SSSS&apos;, 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [&apos;SSSSS&apos;, 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [&apos;SSSSSS&apos;, 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, [&apos;SSSSSSS&apos;, 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, [&apos;SSSSSSSS&apos;, 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, [&apos;SSSSSSSSS&apos;, 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias(&apos;millisecond&apos;, &apos;ms&apos;);

    // PRIORITY

    addUnitPriority(&apos;millisecond&apos;, 16);

    // PARSING

    addRegexToken(&apos;S&apos;, match1to3, match1);
    addRegexToken(&apos;SS&apos;, match1to3, match2);
    addRegexToken(&apos;SSS&apos;, match1to3, match3);

    var token, getSetMillisecond;
    for (token = &apos;SSSS&apos;; token.length &lt;= 9; token += &apos;S&apos;) {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt((&apos;0.&apos; + input) * 1000);
    }

    for (token = &apos;S&apos;; token.length &lt;= 9; token += &apos;S&apos;) {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet(&apos;Milliseconds&apos;, false);

    // FORMATTING

    addFormatToken(&apos;z&apos;, 0, 0, &apos;zoneAbbr&apos;);
    addFormatToken(&apos;zz&apos;, 0, 0, &apos;zoneName&apos;);

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? &apos;UTC&apos; : &apos;&apos;;
    }

    function getZoneName() {
        return this._isUTC ? &apos;Coordinated Universal Time&apos; : &apos;&apos;;
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.for != null) {
        proto[Symbol.for(&apos;nodejs.util.inspect.custom&apos;)] = function () {
            return &apos;Moment&lt;&apos; + this.format() + &apos;&gt;&apos;;
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        &apos;dates accessor is deprecated. Use date instead.&apos;,
        getSetDayOfMonth
    );
    proto.months = deprecate(
        &apos;months accessor is deprecated. Use month instead&apos;,
        getSetMonth
    );
    proto.years = deprecate(
        &apos;years accessor is deprecated. Use year instead&apos;,
        getSetYear
    );
    proto.zone = deprecate(
        &apos;moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/&apos;,
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        &apos;isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information&apos;,
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || &apos;&apos;;

        if (index != null) {
            return get$1(format, index, field, &apos;month&apos;);
        }

        var i,
            out = [];
        for (i = 0; i &lt; 12; i++) {
            out[i] = get$1(format, i, field, &apos;month&apos;);
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === &apos;boolean&apos;) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || &apos;&apos;;
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || &apos;&apos;;
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, &apos;day&apos;);
        }

        for (i = 0; i &lt; 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, &apos;day&apos;);
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, &apos;months&apos;);
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, &apos;monthsShort&apos;);
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, &apos;weekdays&apos;);
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, &apos;weekdaysShort&apos;);
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, &apos;weekdaysMin&apos;);
    }

    getSetGlobalLocale(&apos;en&apos;, {
        eras: [
            {
                since: &apos;0001-01-01&apos;,
                until: +Infinity,
                offset: 1,
                name: &apos;Anno Domini&apos;,
                narrow: &apos;AD&apos;,
                abbr: &apos;AD&apos;,
            },
            {
                since: &apos;0000-12-31&apos;,
                until: -Infinity,
                offset: 1,
                name: &apos;Before Christ&apos;,
                narrow: &apos;BC&apos;,
                abbr: &apos;BC&apos;,
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? &apos;th&apos;
                        : b === 1
                        ? &apos;st&apos;
                        : b === 2
                        ? &apos;nd&apos;
                        : b === 3
                        ? &apos;rd&apos;
                        : &apos;th&apos;;
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        &apos;moment.lang is deprecated. Use moment.locale instead.&apos;,
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        &apos;moment.langData is deprecated. Use moment.localeData instead.&apos;,
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, &apos;s&apos;) or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, &apos;s&apos;) or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number &lt; 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds &gt;= 0 &amp;&amp; days &gt;= 0 &amp;&amp; months &gt;= 0) ||
                (milliseconds &lt;= 0 &amp;&amp; days &lt;= 0 &amp;&amp; months &lt;= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -&gt; 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === &apos;month&apos; || units === &apos;quarter&apos; || units === &apos;year&apos;) {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case &apos;month&apos;:
                    return months;
                case &apos;quarter&apos;:
                    return months / 3;
                case &apos;year&apos;:
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case &apos;week&apos;:
                    return days / 7 + milliseconds / 6048e5;
                case &apos;day&apos;:
                    return days + milliseconds / 864e5;
                case &apos;hour&apos;:
                    return days * 24 + milliseconds / 36e5;
                case &apos;minute&apos;:
                    return days * 1440 + milliseconds / 6e4;
                case &apos;second&apos;:
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case &apos;millisecond&apos;:
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error(&apos;Unknown unit &apos; + units);
            }
        }
    }

    // TODO: Use this.as(&apos;ms&apos;)?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs(&apos;ms&apos;),
        asSeconds = makeAs(&apos;s&apos;),
        asMinutes = makeAs(&apos;m&apos;),
        asHours = makeAs(&apos;h&apos;),
        asDays = makeAs(&apos;d&apos;),
        asWeeks = makeAs(&apos;w&apos;),
        asMonths = makeAs(&apos;M&apos;),
        asQuarters = makeAs(&apos;Q&apos;),
        asYears = makeAs(&apos;y&apos;);

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + &apos;s&apos;]() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter(&apos;milliseconds&apos;),
        seconds = makeGetter(&apos;seconds&apos;),
        minutes = makeGetter(&apos;minutes&apos;),
        hours = makeGetter(&apos;hours&apos;),
        days = makeGetter(&apos;days&apos;),
        months = makeGetter(&apos;months&apos;),
        years = makeGetter(&apos;years&apos;);

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as(&apos;s&apos;)),
            minutes = round(duration.as(&apos;m&apos;)),
            hours = round(duration.as(&apos;h&apos;)),
            days = round(duration.as(&apos;d&apos;)),
            months = round(duration.as(&apos;M&apos;)),
            weeks = round(duration.as(&apos;w&apos;)),
            years = round(duration.as(&apos;y&apos;)),
            a =
                (seconds &lt;= thresholds.ss &amp;&amp; [&apos;s&apos;, seconds]) ||
                (seconds &lt; thresholds.s &amp;&amp; [&apos;ss&apos;, seconds]) ||
                (minutes &lt;= 1 &amp;&amp; [&apos;m&apos;]) ||
                (minutes &lt; thresholds.m &amp;&amp; [&apos;mm&apos;, minutes]) ||
                (hours &lt;= 1 &amp;&amp; [&apos;h&apos;]) ||
                (hours &lt; thresholds.h &amp;&amp; [&apos;hh&apos;, hours]) ||
                (days &lt;= 1 &amp;&amp; [&apos;d&apos;]) ||
                (days &lt; thresholds.d &amp;&amp; [&apos;dd&apos;, days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks &lt;= 1 &amp;&amp; [&apos;w&apos;]) ||
                (weeks &lt; thresholds.w &amp;&amp; [&apos;ww&apos;, weeks]);
        }
        a = a ||
            (months &lt;= 1 &amp;&amp; [&apos;M&apos;]) ||
            (months &lt; thresholds.M &amp;&amp; [&apos;MM&apos;, months]) ||
            (years &lt;= 1 &amp;&amp; [&apos;y&apos;]) || [&apos;yy&apos;, years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration &gt; 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === &apos;function&apos;) {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === &apos;s&apos;) {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === &apos;object&apos;) {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === &apos;boolean&apos;) {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === &apos;object&apos;) {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null &amp;&amp; argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x &gt; 0) - (x &lt; 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#&apos;s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return &apos;P0D&apos;;
        }

        // 3600 seconds -&gt; 60 minutes -&gt; 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -&gt; 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, &apos;&apos;) : &apos;&apos;;

        totalSign = total &lt; 0 ? &apos;-&apos; : &apos;&apos;;
        ymSign = sign(this._months) !== sign(total) ? &apos;-&apos; : &apos;&apos;;
        daysSign = sign(this._days) !== sign(total) ? &apos;-&apos; : &apos;&apos;;
        hmsSign = sign(this._milliseconds) !== sign(total) ? &apos;-&apos; : &apos;&apos;;

        return (
            totalSign +
            &apos;P&apos; +
            (years ? ymSign + years + &apos;Y&apos; : &apos;&apos;) +
            (months ? ymSign + months + &apos;M&apos; : &apos;&apos;) +
            (days ? daysSign + days + &apos;D&apos; : &apos;&apos;) +
            (hours || minutes || seconds ? &apos;T&apos; : &apos;&apos;) +
            (hours ? hmsSign + hours + &apos;H&apos; : &apos;&apos;) +
            (minutes ? hmsSign + minutes + &apos;M&apos; : &apos;&apos;) +
            (seconds ? hmsSign + s + &apos;S&apos; : &apos;&apos;)
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        &apos;toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)&apos;,
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken(&apos;X&apos;, 0, 0, &apos;unix&apos;);
    addFormatToken(&apos;x&apos;, 0, 0, &apos;valueOf&apos;);

    // PARSING

    addRegexToken(&apos;x&apos;, matchSigned);
    addRegexToken(&apos;X&apos;, matchTimestamp);
    addParseToken(&apos;X&apos;, function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken(&apos;x&apos;, function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = &apos;2.29.1&apos;;

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: &apos;YYYY-MM-DDTHH:mm&apos;, // &lt;input type=&quot;datetime-local&quot; /&gt;
        DATETIME_LOCAL_SECONDS: &apos;YYYY-MM-DDTHH:mm:ss&apos;, // &lt;input type=&quot;datetime-local&quot; step=&quot;1&quot; /&gt;
        DATETIME_LOCAL_MS: &apos;YYYY-MM-DDTHH:mm:ss.SSS&apos;, // &lt;input type=&quot;datetime-local&quot; step=&quot;0.001&quot; /&gt;
        DATE: &apos;YYYY-MM-DD&apos;, // &lt;input type=&quot;date&quot; /&gt;
        TIME: &apos;HH:mm&apos;, // &lt;input type=&quot;time&quot; /&gt;
        TIME_SECONDS: &apos;HH:mm:ss&apos;, // &lt;input type=&quot;time&quot; step=&quot;1&quot; /&gt;
        TIME_MS: &apos;HH:mm:ss.SSS&apos;, // &lt;input type=&quot;time&quot; step=&quot;0.001&quot; /&gt;
        WEEK: &apos;GGGG-[W]WW&apos;, // &lt;input type=&quot;week&quot; /&gt;
        MONTH: &apos;YYYY-MM&apos;, // &lt;input type=&quot;month&quot; /&gt;
    };

    return hooks;

})));</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
    </codeTemplateLibraries>
  </exportData>
</channel>